1. collection framework
    : 배열의 단점을 보완해주는 컬렉션
    - 다수의 객체를 다루기위한 표준화된 프로그래밍 방식
    - 컬렉션을 쉽고 편리하게 다룰 수 있는 다양한 인터페이스와 클래스 제공
    - java.util 패키지에 포함되어있고 JDK1.2부터 제공됨
    - 이미 구현되어 있는 것을 사용함으로써 코딩 시간 감소, 코드 품질 보장, 유지보수 용이

2. List interface ( 순서 O 중복 O )
    : List 인터페이스는 순서가 있는 컬렉션이며 중복 요소를 포함할 수 있으며 인덱스로 모든 요소에 접근할 수 있다.
      ArrayList class, LinkedList class는 List 인터페이스로 구현되었다.

    - void add(int index, Object element) : 지정된 위치(index)에 객체(element)를 추가
    - boolean addAll(int index, Collection c) : 지정된 위치(index)에 컬렉션에 포함된 객체들을 추가
    - Object get(int index) : 지정된 위치(index)에 있는 객체를 반환
    - int indexOf(Object o) : 지정된 객체의 위치(index)를 반환 (List의 첫 번째 요소부터 순방향으로 찾음)
    - int lastIndexOf(Object o) : 지정된 객체의 위치(index)를 반환 (List의 마지막 요소부터 역방향으로 찾음)
    - ListIterator listIterator(), ListIterator listIterator(int index) : List의 객체에 접근할 수 있는 ListIterator를 반환
    - Object remove(int index) : 지정된 위치(index)에 있는 객체를 삭제하고 삭제된 객체를 반환
    - Object set(int index, Object element) : 지정된 위치(index)에 객체(element)를 저장
    - void sort(Comparator c) : 지정된 비교자(comparator)로 List 정렬
    - List subList(int fromIndex, int tolndex) : 지정된 범위(fromIndex부터 tolndex)에 있는 객체 반환

3. Set interface( 순서 X 중복 X )
    : Set 인터페이스는 중복 요소를 포함할 수 없으며 랜덤 액세스를 허용하지않아 iterator 또는 foreach를 이용하여 요소를 탐색할 수 있다.
      HashSet class, TreeSet class, LinkedHashSet class는 Set 인터페이스로 구현되었다.
      Set 인터페이스의 메소드는 Collection 인터페이스의 메소드와 동일하다.

      - boolean add(Object o) : 지정된 객체(o)를 Collection에 추가
      - boolean addAll(Collection c) : Collection의 객체들을 Collection에 추가 (합집합)
      - void clear() : Collection의 모든 객체 삭제
      - boolean contains(Object o) : 지정된 객체(o)가 Collection에 포함되어있는지 확인
      - boolean containsAll(Collection c) : Collection의 객체들이 Collection에 포함되어있는지 확인 (부분집합)
      - boolean equals(Object o) : 동일한 Collection인지 비교
      - int hashCode() : Collection의 hash code를 반환
      - boolean isEmpty() : Collection이 비어있는지 확인
      - Iterator iterator() : Collection의 iterator를 얻어서 반환
      - boolean reamove(Object o) : 지정된 객체 삭제
      - boolean removeAll(Collection c) : 지정된 Collection에 포함된 객체들을 삭제 (차집합)
      - boolean retainAll(Collection c) : 지정된 Collection에 포함된 객체만 남기고 다른 객체들은 Collection에서 삭제, 이 작업 후에 Collection에 변화가 있으면 true를 그렇지 않으면 false를 반환 (교집합)
      - int size() : Collection에 저장된 객체의 개수 반환
      - Object[] toArray() : Collection에 저장된 객체를 객체배열로 반환
      - Object[] toArray(Object[] a) : 지정된 배열에 Collection의 객체를 저장해서 반환

  3. Map interface (순서X, 중복 (key X, value O))
    : Map 인터페이스는 키와 값을 매핑힌다. 중복 키가 존재할 수  없으며 각 키는 하나의 값만 매핑할 수 있다.
      Map의 기본 연산은 put, get, containsKey, containsValue, size, isEmpty 등이 있다.
      HashMap class, TreeMap class, LinkedHashMap class는 Map인터페이스로 구현되었다.

      - void clear() : Map의 모든 객체 삭제
      - boolean containsKey(Object key) : 지정된 key객체와 일치하는 Map의 key 객체가 있는지 확인
      - boolean containsValue(Object value) : 지정된 value객체와 일치하는 Map의 value객체가 있는지 확인
      - Set entrySet() : Map에 저장되어있는 key-value쌍을 Map.Entry타입의 객체로 저장한 Set으로 반환
      - boolean equals(Object o) : 동일한 Map인지 비교
      - Object get(Object key) : 지정한 key객체에 대응하는 value객체를 찾아서 반환
      - int hashCode() : 해시코드를 반환
      - boolean isEmpty() : Map이 비어있는지 확인
      - Set keySet() : Map에 저장된 모든 key객체를 반환
      - Object put(Object key, Object value) : Map에 value객체를 key객체에 연결(mapping)하여 저장
      - void putAll(Map t) : 지정된 Map의 모든 key-value쌍을 추가
      - Object remove(Object key) : 지정한 key객체와 일치하는 key-value객체를 삭제
      - int size() : Map에 저장된 key-value쌍의 개수를 반환
      - Collection values() : Map에 저장된 모든 value객체를 반환

  4. List interface를 구현하는 클래스

    1) ArrayList<E> Class
     - resizable-array이면서 내부적으로 배열을 이용해 순차적으로 요소를 저장하며 비동기이다. (배열기반)
     - 동기화가 필요할때는 Collections.synchronizeList() 메소드를 통해 동기화가 보장되는 List를 반환받아 사용한다.
     - ArrayList 클래스와 유사한 Vector 클래스는 resizable-array이고 동기화를 보장한다.
     - 장점 : 배열은 구조가 간단하고 데이터를 읽는데 걸리는 시간(access time)이 짧다.
     - 단점 : 크기를 변경할 수 없다. 크기를 변경해야하는 경우에는 새로운 배열 생성 후 데이터를 복사해야 하며 큰 배열 생성시 메모리가 낭비된다.

     - ArrayList에 저장된 객체의 삭제과정
        (1) 삭제할 데이터 아래의 데이터를 한 칸씩 위로 복사해서 삭제할 데이터를 덮어쓴다.
        (2) 데이터가 모두 한 칸씩 이동했으므로 마지막 데이터는 null로 변경한다.
        (3) 데이터가 삭제되어 데이터의 개수가 줄었으므로 size의 값을 감소시킨다.
         * 마지막 데이터를 삭제하는 경우 , (1)의 과정(배열의 복사)은 필요없다.

    2) LinkedList<E> Class
     - ArrayList의 배열을 통한 요소 저장의 단점을 극복한 클래스로 내부적으로 연결리스트를 이용하여 요소를 저장한다.
     - 연결리스트는 저장된 요소가 비순차적으로 분포되며, 이러한 요소를 링크(link)로 연결하여 구성한다.
     - ArrayList의 주요 메소드와 Queue, Deque 속성과 메소드를 가지고 있고 비동기이다.
     - 동기화가 필요할때는 Collections.synchronizeList() 메소드를 통해 동기화가 보장되는 List를 반환받아 사용한다.
     - 데이터의 삭제 : 단 한번의 참조 변경만으로 가능
     - 데이터의 추가 : 한번의 Node객체생성과 두 번의 참조 변경만으로 가능

        (1) 단일 연결 리스트 (singly linked list)
            - 장점 : 요소의 저장과 삭제 작업이 다음 요소를 가리키는 참조만 변경하면 되므로 빠르게 처리 가능
            - 단점 : 현재 요소에서 이전 요소로 접근하기가 어려움
        (2) 이중 연결 리스트 (doubly linked list)
            - 이전 요소를 가리키는 참조도 가지는 이중 연결 리스트가 단일 연결 리스트보다 많이 사용됨

            ex)
            <code>
                import java.util.*;

                public class ExLinkedList {
                	public static void main(String[] args) {

                		LinkedList<String> linkList = new LinkedList<String>();

                		// add() 메소드를 이용한 요소의 저장
                		linkList.add("넷");
                		linkList.add("둘");
                		linkList.add("셋");
                		linkList.add("하나");

                		// for문과 get()메소드를 이용한 요소의 출력
                		for(int i=0; i<linkList.size();i++) {
                			System.out.print(linkList.get(i)+" ");
                		}System.out.println();

                		// remove() 메소드를 이용한 요소의 제거
                		linkList.remove(1);

                		// Enhanced for문과 get() 메소드를 이용한 요소의 출력
                		for(String e : linkList) {
                			System.out.print(e+" ");
                		}System.out.println();

                		// set() 메소드를 이용한 요소의 변경
                		linkList.set(2, "둘");

                		for(String e:linkList) {
                			System.out.print(e+" ");
                		}System.out.println();

                		// size() 메소드를 이용한 요소의 총 개수
                		System.out.println("리스트의 크기 : "+linkList.size());
                	}
                }

                /* 출력결과
                넷 둘 셋 하나
                넷 셋 하나
                넷 셋 둘
                리스트의 크기 : 3
                */
            </code>

    3) ArrayList vs LinkedList 성능 비교
      - 순차적으로 데이터를 추가, 삭제할때 : ArrayList가 빠름
      - 비순차적으로 데이터를 추가, 삭제할때 : LinkedList가 빠름
      - 접근시간(access time) : ArrayList가 빠름

    4) Vector <E> Class
     - ArrayList 클래스와 같은 동작을 수행하는 클래스
     - ArrayList와 마찬가지로 List 인터페이스를 상속, ArrayList 클래스에서 사용할 수 있는 메소드와 거의 같음
     - 현재에는 기존 코드와의 호환성을 위해서만 남아있으므로, 벡터 클래스보다는 ArrayList클래스 사용 권장



* 출처 : https://prinha.tistory.com/entry/JAVA%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%9E%90%EB%B0%94-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%ACjava-collection-framework
