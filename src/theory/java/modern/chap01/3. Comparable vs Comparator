* 동작 파라미터화 코드 전달하기 p.67

3. Comparable vs Comparator?
    - Comparable과 Comparator는 모두 인터페이스(interface) 이다.
    - Comparable 인터페이스에는 compareTo(T o) 메소드를 재정의 해주어야 한다.
    - Comparator 인터페이스에는 compareTo(T o1, T o2) 메소드를 재정의 해주어야 한다.

    * 왜 compare method만 구현하는 것일까?
    => Java 8부터는 Interface에서도 일반 메서드를 구현할 수 있도록 변경되었고, 대부분이 default 혹은 static으로 선언된 method로 이루어져 있다.
       default와 static으로 선언된 method가 아니면 추상메서드의 의미로 반드시 재정의가 필요하다.
       default로 선언된 method는 재정의(override)를 할 수 있고, static은 재정의를 할 수 없다.

    3-1. Comparable & Comparator - "객체를 비교할 수 있도록 만든다."
         : 우리는 보통 primitive 타입의 실수 변수(byte, int, double ...)의 경우는 부등호를 갖고 쉽게 비교가 가능하다.
           하지만 객체를 비교할 때는 어떻게 비교할까??
           어떤 필드를 기준으로 비교해야 할 것인가??
           => 본질적으로 객체는 사용자가 기준을 정해주지 않는 이상 어떤 객체가 더 높은 우선순위를 갖는지 판단할 수 없다.
              이러한 문제점을 해결하기 위해 Comparable & Comparator 가 사용된다.

    3-2 Comparable - "자기 자신과 매개변수 객체를 비교"

        1) example
            <code>
                class Student implements Comparable<Student> {

                    int age;			// 나이
                    int classNumber;	// 학급

                    Student(int age, int classNumber) {
                        this.age = age;
                        this.classNumber = classNumber;
                    }

                    @Override
                    public int compareTo(Student o) {

                        // 자기자신의 age가 o의 age보다 크다면 양수
                        if(this.age > o.age) {
                            return 1;
                        }
                        // 자기 자신의 age와 o의 age가 같다면 0
                        else if(this.age == o.age) {
                            return 0;
                        }
                        // 자기 자신의 age가 o의 age보다 작다면 음수
                        else {
                            return -1;
                        }
                    }
                }
            </code>

            - 만약 나이를 기준으로 비교(대소 관계)를 하고자 한다면 위와 같이 코드를 작성한다.
              자기 자신의 age(나이)와 매개변수로 들어온 o의 age의 값을 비교하면 된다.
            - compareTo method는 int 값을 반환하도록 되어있다.
              => '값'을 비교하여 정수를 반환해야 한다는 뜻이며 자기 자신을 기준으로 삼아 상대방과의 대소관계를 파악한다.

            * 자기 자신을 기준으로 상대방과 차이 값을 비교한다면 아래와 같은 코드가 더 효율적이지 않을까?
            <code>
                class Student implements Comparable<Student> {

                    int age;			// 나이
                    int classNumber;	// 학급

                    Student(int age, int classNumber) {
                        this.age = age;
                        this.classNumber = classNumber;
                    }

                    @Override
                    public int compareTo(Student o) {

                        /*
                         * 만약 자신의 age가 o의 age보다 크다면 양수가 반환 될 것이고,
                         * 같다면 0을, 작다면 음수를 반환할 것이다.
                         */
                        return this.age - o.age;
                    }
                }
            </code>

            * 결과적으로 나온 코드
            <code>

                public class Test {
                    public static void main(String[] args)  {

                        Student a = new Student(17, 2);	// 17살 2반
                        Student b = new Student(18, 1);	// 18살 1반


                        int isBig = a.compareTo(b);	// a자기자신과 b객체를 비교한다.

                        if(isBig > 0) {
                            System.out.println("a객체가 b객체보다 큽니다.");
                        }
                        else if(isBig == 0) {
                            System.out.println("두 객체의 크기가 같습니다.");
                        }
                        else {
                            System.out.println("a객체가 b객체보다 작습니다.");
                        }

                    }

                }

                class Student implements Comparable<Student> {

                    int age;			// 나이
                    int classNumber;	// 학급

                    Student(int age, int classNumber) {
                        this.age = age;
                        this.classNumber = classNumber;
                    }

                    @Override
                    public int compareTo(Student o) {
                        return this.age - o.age;
                    }
                }
            </code>

        2) warning (매우 중요)
            - 우리가 편리하게 두 수의 대소비교를 두 수의 차를 통해 음수, 0, 양수로 구분했지만 치명적인 단점이 있다.
                => 뺄셈 과정에서 자료형의 범위를 넘어버리는 경우가 발생할 수 있기 때문이다.
                   (int형의 경우 표현범위는 -2,147,483,648~2,147,483,647 이다.)
            - 자료형에서 주어진 범위의 하한선을 넘어버리는 것을 'Underflow', 상한선을 넘어버리는 것을 'Overflow' 라고 한다.

            ※ compareTo 뿐만 아니라 compare을 구현할 때 Overflow, Underflow가 발생할 여지가 있는지 반드시 확인하고 사용해야 한다.
               특히 primitive 값에 대해 예외를 확인하기 어렵다면 '<', '>', '==' 으로 대소 비교를 해주는 것이 안전하며 일반적으로 권장되는 방식이다.

        3) 특징
           (1) 자기 자신과 매개변수를 비교한다.
           (2) compareTo method를 반드시 구현해야 한다.

    3-3 Comparator - "두 매개변수 객체를 비교"
        1) example
            <code>
                import java.util.Comparator;	// import 필요
                class Student implements Comparator<Student> {

                    int age;			// 나이
                    int classNumber;	// 학급

                    Student(int age, int classNumber) {
                        this.age = age;
                        this.classNumber = classNumber;
                    }

                    @Override
                    public int compare(Student o1, Student o2) {

                        // o1의 학급이 o2의 학급보다 크다면 양수
                        if(o1.classNumber > o2.classNumber) {
                            return 1;
                        }
                        // o1의 학급이 o2의 학급과 같다면 0
                        else if(o1.classNumber == o2.classNumber) {
                            return 0;
                        }
                        // o1의 학급이 o2의 학급보다 작다면 음수
                        else {
                            return -1;
                        }
                    }
                }
            </code>

            - 이번 코드는 학급(classNumber)을 기준으로 비교하는 코드이며 Comparator를 import 해준다.
            - 선행 원소 o1과 후행 원소 o2를 비교함에 있어 자기 자신은 두 객체 비교에 영향이 없다.

            * 이 또한 Comparable과 같이 효율적으로 바꾼다면 아래와 같다.
            <code>
                import java.util.Comparator;

                public class Test {
                    public static void main(String[] args)  {

                        Student a = new Student(17, 2);	// 17살 2반
                        Student b = new Student(18, 1);	// 18살 1반
                        Student c = new Student(15, 3);	// 15살 3반

                        // a객체와는 상관 없이 b와 c객체를 비교한다.
                        int isBig = a.compare(b, c);

                        if(isBig > 0) {
                            System.out.println("b객체가 c객체보다 큽니다.");
                        }
                        else if(isBig == 0) {
                            System.out.println("두 객체의 크기가 같습니다.");
                        }
                        else {
                            System.out.println("b객체가 c객체보다 작습니다.");
                        }

                    }
                }

                class Student implements Comparator<Student> {

                    int age;			// 나이
                    int classNumber;	// 학급

                    Student(int age, int classNumber) {
                        this.age = age;
                        this.classNumber = classNumber;
                    }

                    @Override
                    public int compare(Student o1, Student o2) {
                        return o1.classNumber - o2.classNumber;
                    }
                }
            </code>

        2) warning (매우 중요)
            - Comparable 과 동일하게 Overflow, Underflow를 주의해야 한다. (3-2 Comparable 2) warning 참조)

    3-4 Comparator 활용
        1) 



* 출처 : - https://st-lab.tistory.com/243