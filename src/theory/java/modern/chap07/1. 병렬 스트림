* 모던 자바 인 액션 chap07 - 병렬 스트림 p.242

1. 병렬 스트림
    - 컬렉션에 parallelStream을 호출하면 병렬 스트림이 생성된다.
    - 병렬 스트림이란 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림이다.
    - 아래의 코드는 숫자 n을 인수로 받아서 1부터 n까지의 모든 숫자의 합계를 반환하는 메서드이다.
    <code>
        public long sequentialSum(long n){
            return Stream.iterate(1L, i -> i + 1)
                    .limit(n)
                    .reduce(0L, Long::sum);
        }
    </code>

    - 전통적인 자바에서는 다음과 같이 반복문으로 이를 구현할 수 있다.
    <code>
        public long iterativeSum(long n){
            long result = 0;
            for (long i = 1L; i <= n; i++) {
                result += i;
            }
            return result;
        }
    </code>
    => n이 커진다면 이 연산을 병렬로 처리하는 것이 좋을 것이다.
       무엇부터 건드려야하며, 결과와 변수는 어떻게 동기화하며, 몇 개의 스레드를 사용해야하며, 숫자는 어떻게 생성하며, 생성된 숫자는 누가 더하면 좋을까?
       병렬 스트림을 이용하면 위의 모든 문제를 쉽게 해결할 수 있다.

    1) 순차 스트림을 병렬 스트림으로 변환하기
        - 순차 스트림에 parallel 메서드를 호출하면 기존의 함수형 리듀싱 연산(숫자 합계 계산)이 병렬로 처리된다.
        <code>
            public long parallelSum(long n) {
                return Stream.iterate(1L, i -> i + 1)
                        .limit(n)
                        .parallel()
                        .reduce(0L, Long::sum);
            }
        </code>

       - 병렬 스트림은 내부적으로 ForkJoinPoll을 사용한다.

    2) 병렬 스트림 효과적으로 사용하기
        - '천 개 이상의 요소가 있을 때만 병렬 스트림을 사용하라'와 같이 양을 기준으로 병렬 스트림 사용을 결정하는 것은 적절하지 않다.

        (1) 확신이 서지 않으면 직접 측정하라.
            - 병렬 스트림의 수행 괒어은 투명하지 않을 때가 많다.
            - 순차 스트림을 병렬 스트림으로 쉽게 바꿀 수 있기에 적절한 벤치마크로 직접 성능을 측정하는 것이 바람직하다.

        (2) 박싱을 주의하라.
            - 자동 박싱과 언박싱은 성능을 크게 저하시킬 수 있는 요소이다.
            - 자바 8은 박싱 동작을 피할 수 있도로 기본 특화 스트림 (IntStream, LongStream, DoubleStream)을 제공한다.

        (3) 순차 스트림보다 병렬 스트림에서 성능이 떨어지는 연산이 있다.
            - limit이나 findFirst처럼 요소의 순서에 의존하는 연산을 병렬 스트림에서 수행하려면 비싼 비용을 치러야 한다.
            - 예를 들어 findAny는 요소의 순서와 상관없이 연산하므로 findFirst보다 성능이 좋다.
            - 스트림에 N개 요소가 있을 때 요소의 순서가 상관없다면 비정렬된 스트림(소스가 리스트인 상황 등)에 limit을 호출하는 것이 효율적이다.

        (4) 스트림에서 수행하는 전체 파이프라인 연산 비용을 고려하라.
            - 처리해야 할 요소 수가 N이고 하나의 요소를 처리하는 데 드는 비용을 Q라고 하면 전체 스트림 파이프라인 처리 비용을 N*Q로 예상할 수 있다.
            - Q가 높아진다는 것은 병렬 스트림으로 성능을 개선할 수 있는 간으성이 있음을 의미한다.

        (5) 소량의 데이터에서는 병렬 스트림이 도움되지 않는다.

        (6) 스트림을 구성하는 자료구조가 적절한지 확인하라.
            - 예를 들어 ArrayList를 LinkedList보다 효율적으로 분할할 수 있다.
            - LinkedList를 분할하려면 모든 요소를 탐색해야 하지만 ArrayList는 요소를 탐색하지 않고도 리스트를 분할할 수 있기 때문이다.
            * 스트림 소스와 분해성
                - 분해성이 훌륭함 : ArrayList, IntStream.range
                - 분해성이 나쁨 : LinkedList, Stream.iterate
                - 분해성이 좋음 : HashSet, TreeSet

        (7) 스트림의 특성과 파이프라인의 중간 연산이 스트림의 특성을 어떻게 바꾸는지에 따라 분해 과정의 성능이 달라질 수 있다.
            - 예를 들어 SIZED 스트림은 정확히 같은 크기의 두 스트림으로 분할할 수 있으므로 효과적으로 스트림을 병렬 처리할 수 있다.
            - 하지만 필터 연산이 있으면 스트림의 길이를 예측할 수 없으므로 효과적으로 병렬 처리할 수 있을지 알 수 없게 된다.

        (8) 최종 연산의 병합 과정(Collector의 combiner) 비용을 살펴보라.

2. 포크/조인 프레임워크
    - 포크/조인 프레임워크는 병렬화할 수 있는 작업ㅇ르 재귀적으로 작은 작업으로 분할한 다음에 서브테스크 각각의 결과를 합쳐서 전체 결과를 만들도록 설계되었다.
    - 포크/조인 프레임워크에서는 서브테스크를 스레드풀(ForkJoinPool)의 작업자 스레드에 분산 할당하는 ExcutorService 인터페이스를 구현한다.

    1) RecursiveTask 활용
        - 스레드 풀을 이용하려면 RecursiveTask<R> 서브클래스를 만들어야 한다.
        - 여기서 R은 병렬화된 테스크가 생성하는 결과 형식 또는 결과가 없을 때 RecursiveAction 형식이다.
        - RecursiveTask를 정의하려면 추상 메서드인 compute를 구현해야 한다.
        - compute 메서드 구현
        <code>
            if(테스크가 충분히 작거나 더 이상 분할할 수 없으면){
                순차적으로 테스크 계산
            }else{
                테스크를 두 서브테스크로 분할
                테스크가 다시 서브테스크로 분할되도록 이 메서드를 재귀적으로 호출함
                모든 서브 테스크의 연산이 완료될 때까지 기다림
                각 서브테스크의 결과를 합침
            }
        </code>
        => 이 알고리즘은 분할 후 정복(divide-and-conquer) 알고리즘의 병렬화 버전이다.

        - n까지의 자연수 덧셈 작업을 병렬로 수행하는 방법을 직관적으로 나타낼 수 있다.
        - 예제 : src/theory/java/modern/chap07/ForkJoinSumCalculator.java 참조




